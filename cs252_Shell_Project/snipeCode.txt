
/*
 *
 * CS-252 Fall 2013
 * shell.l: lexical analyzer for shell
 * You have to extend it.
 *
 */

%{

#include <string.h>
#include "y.tab.h"
#include <regex.h>
//extern yy_buffer_state;
//typedef yy_buffer_state *YY_BUFFER_STATE;
extern int yyparse();
extern YY_BUFFER_STATE yy_scan_buffer(char*,size_t);
static  void yyunput (int c,char *buf_ptr  );

void myunputc(int c) {
    unput(c);
}

%}
%%
[\\]*`[^\n\`]*[\\]*` 	{
			char *com = strdup(yytext);
			printf("%s\n",yytext);
			if (strchr(com,'\\')) {
				com += 2;
				com[yyleng-4] = '\0';
			}
			else {
				com++;
				com[yyleng-2] = '\0';
			}
			int tempin = dup(0);
			int tempout = dup(1);
			//int temperr = dup(2);
			int fdpipein[2];
			int fdpipeout[2];
			pipe(fdpipein);
			pipe(fdpipeout);

			write(fdpipein[1],com,strlen(com));
			write(fdpipein[1],"\n",1);		
			write(fdpipein[1],"exit\n",5);
			printf("%s\n",com);
			dup2(fdpipeout[1],1);
			close(fdpipeout[1]);
			dup2(fdpipein[0],0);
			close(fdpipein[0]);
			int ret = fork();
			if (ret == 0) {
				//child
				//call execvp
				char *str = new char[256];
				char ch;
				int i= 0;
				while (read(fdpipein[0],&ch,1)) {
					if (ch != '\n') {
						str[i++] = ch;
					}
					else {
						str[i] = '\0';
						//printf("got it\n");
						//yy_scan_buffer(str,i*sizeof(char));
						//char*const*list = {(const char*)str,};
						execlp("/proc/self/exe",str,NULL);
					//	free(list);
						i = 0;
					}
				}
			
				_exit(1);
			}
			else if (ret < 0) {
				perror("fork");
				_exit(1);
			}
			dup2(tempin,0);
			dup2(tempout,1);
			close(tempin);
			close(tempout);

			char*buffer = new char[256];
			char p;
			int i = 0;
			while (read(fdpipeout[0],&p,1)) {
				buffer[i] = p;
				i++;
			}
			buffer[i] = '\0';
			i--;
			while (i >= 0 ) {
				myunputc(buffer[i--]);
			}
			yylval.string_val = strdup(buffer);

		}
\"[^\n\"]*\" {
		int i = 0;
		for (i = 0;i < yyleng-2;i++) {
			yytext[i] = yytext[i+1];
		}
		yytext[i] = '\0';
		yylval.string_val = strdup(yytext);
		return WORD;
	}
[^ \n\t]*[\\][^ \n\t]* {
		//printf("%s\n",yytext);
		int i = 0;
		int p = 0;
		char temp[1024];
		while (yytext[i] != '\0') {
			if (yytext[i] == '\\') {
				i++;
			}
			temp[p] = yytext[i];
			p++;
			i++;
		}
		temp[p] = '\0';
		yylval.string_val = strdup(temp);
		return WORD;
	}
\n 	{
		return NEWLINE;
	}

[ \t] 	{
		/* Discard spaces and tabs */
     	}

">" 	{
		return GREAT;
	}

">>"    {
		return GREATGREAT;
        }

"|"	{	
		return PIPE;
	}

"&"	{
		return AMPERSAND;
	}

">>&"   {
		return GREATGREATAMPERSAND;
	}

">&"	{
		return GREATAMPERSAND;
	}

"<"	{
		return LESS;
	}
[^ \t\n][^ \t\n]*  {
		/* Assume that file names have only alpha chars */
		char *pat = "[<|>|\\&|\\|]";
		char *temp = strdup(yytext);
		regex_t reg;
		size_t nmatch=2;
		regmatch_t match[2];
		if (regcomp(&reg,pat,0)) {
			perror("compile");
			exit(1);
		}
		  //printf("%s\n",yytext);

		if (!regexec(&reg,yytext,nmatch,match,0)) {
			int i = 0;
			int j = 0;
			temp = new char[strlen(yytext)+2];
			//printf("%s\n",yytext);
			while (yytext[i]) {
				if (i != match[0].rm_so) {
					temp[j++] = yytext[i++];
				}
				else {
					temp[j++] = ' ';
					temp[j++] = yytext[i++];
					temp[j++] = ' ';
				}
			}
			temp[j] = '\0';
			//fprintf(stderr,"CHECK-> %s\n",temp);
			j = strlen(temp)-1;
			while (j >=0) {
				myunputc(temp[j]);
				j--;
			}
			yylval.string_val = strdup(temp);
			

		}	
		else {
			yylval.string_val = strdup(temp);
			return WORD;
		}
	}

